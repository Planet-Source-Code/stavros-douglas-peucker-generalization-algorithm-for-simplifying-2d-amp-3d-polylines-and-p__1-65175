VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsGeneralize"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
'++----------------------------------------------------------------------------
'//   CLS_GENERALIZE
'//     author: Stavros Sirigos
'++----------------------------------------------------------------------------
'//   DOUGLAS-PEUCKER GEOMETRY GENERALIZATION ALGORITHM
'++----------------------------------------------------------------------------
'//   - Iterative 2D and 3D versions to simplify a polyline chain
'//   - Can be easily extended into N-dimensions
'++----------------------------------------------------------------------------
'
'BACKGROUND:
'
'In 1973, David H. Douglas and Thomas K. Peucker wrote an article in Canadian
'Cartographer magazine explaining how they developed an algorithm for reducing
'the number of points in a polyline, when the polyline needs to be displayed at
'a lower resolution.
'
'The process of generalization is normally executed when the map scale has to
'be reduced. Another usage is in cleaning up noisy representations of polylines,
'possibly generated by a raster-to-vector conversion (tracing). Generalization
'is a form of lossy data compression: given a large and complicated object,
'we seek to simplify it by reducing detail. Ideally, we obtain a polyline/polygon
'with far fewer vertices that looks essentially the same at a target scale.
'This can be a big win in computer graphics, where replacing a large model with
'a smaller one might have little visual impact but require significantly less
'storage space and rendering time.

'PSEUDOCODE:
'
'"Simplify an array of n points p1 ... pn given a tolerance t"
'
'   1. Find the point whose perpendicular distance from the line segment
'      connecting  p1 ... pn is the greatest. Call the point pb and this maximal distance db
'   2. If db < t,
'          * then throw away all of the points p2...pn-1
'          * else
'               1. Simplify the array of n points p1 ... pb given tolerance t
'               2. Simplify the array of points pb..pn given tolerance t.

'IMPLEMENTATION NOTE:
'
'We use an iterative version of the algorithm, since recursive versions can
'produce stack overflow errors for "pathological" cases of input data
'(e.g. in a very long /\/\/\/\/\/\/\/\ shaped polyline).
'
'ToDo:  - Add option for normalized (0-1 ranged) coordinates
'       - Add binary search routine to achieve a pre-specified % reduction ratio
'       - Implement the general algorithm for N-dimensions

Option Explicit

'3D polyline chain building block
Private Type Type_Point
    X           As Double
    Y           As Double
    Z           As Double
End Type

'Stack type - holds information about pending polyline
'             sub-chains to be processed in subsequent
'             iterations. We add/remove elements in
'             'Last In - First Out' order.
Private Type Type_Stack
    LB()        As Long
    UB()        As Long
    CurElement  As Long
    EmptyElem   As Long
    zMaxDepth   As Long 'For reporting only
    zTotalIter  As Long 'For reporting only
End Type

Private m_uPoly()       As Type_Point
Private m_uStack        As Type_Stack
Private m_blRetain()    As Boolean 'Polyline points that remain in the simplified version

Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)

'++----------------------------------------------------------------------------
'//   CLASS_INITIALIZE
'++----------------------------------------------------------------------------
Private Sub Class_Initialize()
    ReDim m_uPoly(1)
End Sub

'++----------------------------------------------------------------------------
'//   MAXIMUM STACK DEPTH (worst case = UBound(m_uPoly))
'++----------------------------------------------------------------------------
Public Property Get MaxDepth() As Long
    MaxDepth = m_uStack.zMaxDepth
End Property

'++----------------------------------------------------------------------------
'//   ITERATIONS PERFORMED (worst case = UBound(m_uPoly))
'++----------------------------------------------------------------------------
Public Property Get Iterations() As Long
    Iterations = m_uStack.zTotalIter
End Property

'++----------------------------------------------------------------------------
'//   LOCAL COPY OF POLYLINE DATA
'++----------------------------------------------------------------------------
'//   - Accepts a pointer to a Type_Point and the total bytes to be copied
'++----------------------------------------------------------------------------
Public Sub LetPolyline(ByVal lPtr As Long, ByVal lByteLen As Long)
  Dim uTmp As Type_Point
  
    ReDim m_uPoly(1 To lByteLen \ LenB(uTmp))
    CopyMemory ByVal VarPtr(m_uPoly(1)), ByVal lPtr, lByteLen
End Sub

'++----------------------------------------------------------------------------
'//   PASS ARRAY OF WHICH POINTS REMAIN IN THE SIMPLIFIED POLYLINE
'++----------------------------------------------------------------------------
Public Sub GetResult(blDeletedVertices() As Boolean)
    blDeletedVertices = m_blRetain
End Sub

'++----------------------------------------------------------------------------
'//   GENERALIZE - INITIALIZATION PHASE
'++----------------------------------------------------------------------------
Public Function Generalize(Optional ByVal dTolerance As Double, _
                           Optional ByVal bl3D As Boolean) As Long
  
  Dim lUB As Long
    
    lUB = UBound(m_uPoly)
  
    If lUB > 0 Then
    
        With m_uStack
            ReDim m_blRetain(1 To lUB)
            ReDim .LB(1 To lUB)
            ReDim .UB(1 To lUB)
            .CurElement = 1
            .EmptyElem = .CurElement - 1
            .LB(.CurElement) = 1
            .UB(.CurElement) = lUB
            .zMaxDepth = 1
            .zTotalIter = 1
            m_blRetain(1) = True
            m_blRetain(lUB) = True
        End With
           
        If bl3D Then
            DouglasPeucker3D dTolerance
        Else
            DouglasPeucker2D dTolerance
        End If
        
        Generalize = 1
        
    Else
        m_uStack.zMaxDepth = 0
        m_uStack.zTotalIter = 0
    End If
    
End Function

'++----------------------------------------------------------------------------
'//   DOUGLAS-PEUCKER 2D iterative version
'++----------------------------------------------------------------------------
Private Sub DouglasPeucker2D(Optional ByVal dTolerance As Double)
                            
                            'current reffers to current iteration
  Dim i         As Long
  Dim X1        As Double   'current left polyline vertex X-coord
  Dim Y1        As Double   'current left polyline vertex Y-coord
  Dim X2_X1     As Double   'current left polyline vertex X-coord - X1
  Dim Y2_Y1     As Double   'current left polyline vertex Y-coord - Y1
  Dim dCrossPrd As Double   'Cross product of <X1,Y1><X2,Y2><Xi,Yi>
  Dim dMaxCP    As Double   'Max.Cross product of <X1,Y1><X2,Y2><XlRet,YlRet>
  Dim lRet      As Long     'current polyline vertex to be retained
  Dim LB        As Long     'current left polyline vertex
  Dim UB        As Long     'current right polyline vertex
            
    dTolerance = dTolerance * dTolerance 'Use square of values to avoid Sqr() later
            
    Do Until StackIsEmpty
        
        StackNext LB, UB
        
        dMaxCP = 0
        X1 = m_uPoly(LB).X
        Y1 = m_uPoly(LB).Y
        X2_X1 = m_uPoly(UB).X - X1
        Y2_Y1 = m_uPoly(UB).Y - Y1
        
        If X2_X1 <> 0 Or Y2_Y1 <> 0 Then

            For i = LB + 1 To UB - 1
                'Determine the cross product between the vectors
                dCrossPrd = Abs((Y1 - m_uPoly(i).Y) * X2_X1 - _
                                (X1 - m_uPoly(i).X) * Y2_Y1)

                If dCrossPrd > dMaxCP Then 'retain the maximum value
                    dMaxCP = dCrossPrd
                    lRet = i
                End If
            Next i
            'Determine the square perpendicullar distance of the Point lRet to the Line (LB,UB)
            dMaxCP = (dMaxCP * dMaxCP) / (X2_X1 * X2_X1 + Y2_Y1 * Y2_Y1)

            If dTolerance = 0 Then
                'a default tolerance, in case a tolerance was not specified
                dTolerance = (dMaxCP * dMaxCP / 10000000000#)
            End If
        Else
            StackAdd LB, UB - 1 'Update: Handles special case when endpoints coincide
        End If
        
        If dTolerance Then
            If dMaxCP > dTolerance Then
                'Split the polyline and process each part
                m_blRetain(lRet) = True
                StackAdd LB, lRet
                StackAdd lRet, UB
            End If
        End If
        
    Loop
    
End Sub

'++----------------------------------------------------------------------------
'//   DOUGLAS-PEUCKER 3D iterative version
'++----------------------------------------------------------------------------
Private Sub DouglasPeucker3D(Optional ByVal dTolerance As Double)
  
                            'current reffers to current iteration
  Dim i         As Long
  Dim X1        As Double   'current left polyline vertex X-coord
  Dim Y1        As Double   'current left polyline vertex Y-coord
  Dim Z1        As Double   'current left polyline vertex Z-coord
  Dim X2_X1     As Double   'current left polyline vertex X-coord - X1
  Dim Y2_Y1     As Double   'current left polyline vertex Y-coord - Y1
  Dim Z2_Z1     As Double   'current left polyline vertex Z-coord - Z1
  Dim dCrossPrd As Double   'Cross product of <X1,Y1,Z1><X2,Y2,Z2><Xi,Yi,Zi>
  Dim dMaxCP    As Double   'Max.Cross product of <X1,Y1,Z1><X2,Y2,Z2><XlRet,YlRet,ZlRet>
  Dim lRet      As Long     'current polyline vertex to be retained
  Dim LB        As Long     'current left polyline vertex
  Dim UB        As Long     'current right polyline vertex
    
    dTolerance = dTolerance * dTolerance 'Use square of values to avoid Sqr() later
    
    Do Until StackIsEmpty
        
        StackNext LB, UB 'Retrieve next stack element properties

        dMaxCP = 0
        X1 = m_uPoly(LB).X
        Y1 = m_uPoly(LB).Y
        Z1 = m_uPoly(LB).Z
        X2_X1 = m_uPoly(UB).X - X1
        Y2_Y1 = m_uPoly(UB).Y - Y1
        Z2_Z1 = m_uPoly(UB).Z - Z1
        
        If X2_X1 <> 0 Or Y2_Y1 <> 0 Or Z2_Z1 <> 0 Then
            
            For i = LB + 1 To UB - 1
                With m_uPoly(i)
                    'Determine the cross product between the vectors
                    dCrossPrd = ((Z1 - .Z) * Y2_Y1 - (Y1 - .Y) * Z2_Z1) * _
                                ((Z1 - .Z) * Y2_Y1 - (Y1 - .Y) * Z2_Z1) + _
                                ((Z1 - .Z) * X2_X1 - (X1 - .X) * Z2_Z1) * _
                                ((Z1 - .Z) * X2_X1 - (X1 - .X) * Z2_Z1) + _
                                ((Y1 - .Y) * X2_X1 - (X1 - .X) * Y2_Y1) * _
                                ((Y1 - .Y) * X2_X1 - (X1 - .X) * Y2_Y1)
                End With
                
                If dCrossPrd > dMaxCP Then 'retain the maximum value
                    dMaxCP = dCrossPrd
                    lRet = i
                End If
            Next i
            'Determine the square perpendicullar distance of the Point lRet to the Line (LB,UB)
            dMaxCP = dMaxCP / (X2_X1 * X2_X1 + Y2_Y1 * Y2_Y1 + Z2_Z1 * Z2_Z1)
            
            If dTolerance = 0 Then
                'a default tolerance, in case a tolerance was not specified
                dTolerance = (dMaxCP * dMaxCP / 10000000000#)
            End If
        Else
            StackAdd LB, UB - 1 'Update: Handles special case when endpoints coincide
        End If
        
        If dTolerance Then
            If dMaxCP > dTolerance Then
                'Split the polyline and process each part
                m_blRetain(lRet) = True
                StackAdd LB, lRet
                StackAdd lRet, UB
            End If
        End If
        
    Loop
    
End Sub

'++----------------------------------------------------------------------------
'//   IS THE STACK EMPTY ?
'++----------------------------------------------------------------------------
Private Function StackIsEmpty() As Boolean
    StackIsEmpty = m_uStack.CurElement <= m_uStack.EmptyElem
End Function

'++----------------------------------------------------------------------------
'//   RETRIEVE NEXT STACK ELEMENT PROPERTIES AND REMOVE FROM STACK
'++----------------------------------------------------------------------------
Private Sub StackNext(ByRef LB As Long, ByRef UB As Long)
    With m_uStack
        LB = .LB(.CurElement)
        UB = .UB(.CurElement)
        .CurElement = .CurElement - 1
    End With
End Sub

'++----------------------------------------------------------------------------
'//   ADD A NEW STACK ELEMENT (push)
'++----------------------------------------------------------------------------
Private Sub StackAdd(ByVal LB As Long, ByVal UB As Long)
    With m_uStack
        If UB - LB > 1 Then
            .CurElement = .CurElement + 1
            .LB(.CurElement) = LB
            .UB(.CurElement) = UB
            
            'Used for application reporting only
            .zTotalIter = .zTotalIter + 1
            If .CurElement > .zMaxDepth Then .zMaxDepth = .CurElement
        End If
    End With
End Sub
